// Layer Declaration header
//
// This file is auto-generated by cmake, don't edit it.

#include "layer/batchnorm.h"
namespace ncnn {
class BatchNorm_final : virtual public BatchNorm
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = BatchNorm::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = BatchNorm::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(BatchNorm_final)
} // namespace ncnn

#include "layer/bias.h"
namespace ncnn {
class Bias_final : virtual public Bias
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Bias::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Bias::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Bias_final)
} // namespace ncnn

#include "layer/concat.h"
namespace ncnn {
class Concat_final : virtual public Concat
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Concat::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Concat::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Concat_final)
} // namespace ncnn

#include "layer/convolution.h"
namespace ncnn {
class Convolution_final : virtual public Convolution
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Convolution::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Convolution::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Convolution_final)
} // namespace ncnn

#include "layer/crop.h"
namespace ncnn {
class Crop_final : virtual public Crop
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Crop::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Crop::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Crop_final)
} // namespace ncnn

#include "layer/divtrilwhere.h"
namespace ncnn {
class DivTrilWhere_final : virtual public DivTrilWhere
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = DivTrilWhere::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = DivTrilWhere::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(DivTrilWhere_final)
} // namespace ncnn

#include "layer/eltwise.h"
namespace ncnn {
class Eltwise_final : virtual public Eltwise
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Eltwise::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Eltwise::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Eltwise_final)
} // namespace ncnn

#include "layer/flatten.h"
namespace ncnn {
class Flatten_final : virtual public Flatten
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Flatten::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Flatten::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Flatten_final)
} // namespace ncnn

#include "layer/gather.h"
namespace ncnn {
class Gather_final : virtual public Gather
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Gather::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Gather::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Gather_final)
} // namespace ncnn

#include "layer/innerproduct.h"
namespace ncnn {
class InnerProduct_final : virtual public InnerProduct
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = InnerProduct::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = InnerProduct::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(InnerProduct_final)
} // namespace ncnn

#include "layer/input.h"
namespace ncnn {
class Input_final : virtual public Input
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Input::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Input::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Input_final)
} // namespace ncnn

#include "layer/memorydata.h"
namespace ncnn {
class MemoryData_final : virtual public MemoryData
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = MemoryData::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = MemoryData::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(MemoryData_final)
} // namespace ncnn

#include "layer/pooling.h"
namespace ncnn {
class Pooling_final : virtual public Pooling
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Pooling::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Pooling::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Pooling_final)
} // namespace ncnn

#include "layer/relu.h"
namespace ncnn {
class ReLU_final : virtual public ReLU
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = ReLU::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = ReLU::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(ReLU_final)
} // namespace ncnn

#include "layer/reshape.h"
namespace ncnn {
class Reshape_final : virtual public Reshape
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Reshape::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Reshape::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Reshape_final)
} // namespace ncnn

#include "layer/scale.h"
namespace ncnn {
class Scale_final : virtual public Scale
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Scale::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Scale::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Scale_final)
} // namespace ncnn

#include "layer/sigmoid.h"
namespace ncnn {
class Sigmoid_final : virtual public Sigmoid
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Sigmoid::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Sigmoid::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Sigmoid_final)
} // namespace ncnn

#include "layer/slice.h"
namespace ncnn {
class Slice_final : virtual public Slice
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Slice::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Slice::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Slice_final)
} // namespace ncnn

#include "layer/softmax.h"
namespace ncnn {
class Softmax_final : virtual public Softmax
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Softmax::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Softmax::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Softmax_final)
} // namespace ncnn

#include "layer/split.h"
namespace ncnn {
class Split_final : virtual public Split
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Split::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Split::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Split_final)
} // namespace ncnn

#include "layer/rnn.h"
namespace ncnn {
class RNN_final : virtual public RNN
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = RNN::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = RNN::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(RNN_final)
} // namespace ncnn

#include "layer/lstm.h"
namespace ncnn {
class LSTM_final : virtual public LSTM
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = LSTM::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = LSTM::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(LSTM_final)
} // namespace ncnn

#include "layer/binaryop.h"
namespace ncnn {
class BinaryOp_final : virtual public BinaryOp
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = BinaryOp::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = BinaryOp::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(BinaryOp_final)
} // namespace ncnn

#include "layer/unaryop.h"
namespace ncnn {
class UnaryOp_final : virtual public UnaryOp
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = UnaryOp::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = UnaryOp::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(UnaryOp_final)
} // namespace ncnn

#include "layer/convolutiondepthwise.h"
namespace ncnn {
class ConvolutionDepthWise_final : virtual public ConvolutionDepthWise
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = ConvolutionDepthWise::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = ConvolutionDepthWise::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(ConvolutionDepthWise_final)
} // namespace ncnn

#include "layer/padding.h"
namespace ncnn {
class Padding_final : virtual public Padding
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Padding::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Padding::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Padding_final)
} // namespace ncnn

#include "layer/squeeze.h"
namespace ncnn {
class Squeeze_final : virtual public Squeeze
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Squeeze::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Squeeze::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Squeeze_final)
} // namespace ncnn

#include "layer/normalize.h"
namespace ncnn {
class Normalize_final : virtual public Normalize
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Normalize::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Normalize::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Normalize_final)
} // namespace ncnn

#include "layer/permute.h"
namespace ncnn {
class Permute_final : virtual public Permute
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Permute::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Permute::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Permute_final)
} // namespace ncnn

#include "layer/interp.h"
namespace ncnn {
class Interp_final : virtual public Interp
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Interp::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Interp::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Interp_final)
} // namespace ncnn

#include "layer/shufflechannel.h"
namespace ncnn {
class ShuffleChannel_final : virtual public ShuffleChannel
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = ShuffleChannel::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = ShuffleChannel::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(ShuffleChannel_final)
} // namespace ncnn

#include "layer/clip.h"
namespace ncnn {
class Clip_final : virtual public Clip
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Clip::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Clip::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Clip_final)
} // namespace ncnn

#include "layer/quantize.h"
namespace ncnn {
class Quantize_final : virtual public Quantize
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Quantize::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Quantize::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Quantize_final)
} // namespace ncnn

#include "layer/dequantize.h"
namespace ncnn {
class Dequantize_final : virtual public Dequantize
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Dequantize::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Dequantize::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Dequantize_final)
} // namespace ncnn

#include "layer/packing.h"
namespace ncnn {
class Packing_final : virtual public Packing
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Packing::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Packing::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Packing_final)
} // namespace ncnn

#include "layer/requantize.h"
namespace ncnn {
class Requantize_final : virtual public Requantize
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Requantize::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Requantize::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Requantize_final)
} // namespace ncnn

#include "layer/cast.h"
namespace ncnn {
class Cast_final : virtual public Cast
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Cast::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Cast::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Cast_final)
} // namespace ncnn

#include "layer/hardswish.h"
namespace ncnn {
class HardSwish_final : virtual public HardSwish
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = HardSwish::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = HardSwish::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(HardSwish_final)
} // namespace ncnn

#include "layer/noop.h"
namespace ncnn {
class Noop_final : virtual public Noop
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Noop::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Noop::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Noop_final)
} // namespace ncnn

#include "layer/deepcopy.h"
namespace ncnn {
class DeepCopy_final : virtual public DeepCopy
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = DeepCopy::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = DeepCopy::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(DeepCopy_final)
} // namespace ncnn

#include "layer/mish.h"
namespace ncnn {
class Mish_final : virtual public Mish
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Mish::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Mish::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Mish_final)
} // namespace ncnn

#include "layer/gemm.h"
namespace ncnn {
class Gemm_final : virtual public Gemm
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = Gemm::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = Gemm::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(Gemm_final)
} // namespace ncnn

#include "layer/groupnorm.h"
namespace ncnn {
class GroupNorm_final : virtual public GroupNorm
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = GroupNorm::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = GroupNorm::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(GroupNorm_final)
} // namespace ncnn

#include "layer/layernorm.h"
namespace ncnn {
class LayerNorm_final : virtual public LayerNorm
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = LayerNorm::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = LayerNorm::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(LayerNorm_final)
} // namespace ncnn

#include "layer/multiheadattention.h"
namespace ncnn {
class MultiHeadAttention_final : virtual public MultiHeadAttention
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = MultiHeadAttention::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = MultiHeadAttention::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(MultiHeadAttention_final)
} // namespace ncnn

#include "layer/gelu.h"
namespace ncnn {
class GELU_final : virtual public GELU
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = GELU::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = GELU::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(GELU_final)
} // namespace ncnn

#include "layer/matmul.h"
namespace ncnn {
class MatMul_final : virtual public MatMul
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = MatMul::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = MatMul::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(MatMul_final)
} // namespace ncnn

#include "layer/lifnode.h"
namespace ncnn {
class LIFNode_final : virtual public LIFNode
{
public:
    virtual int create_pipeline(const Option& opt) {
        { int ret = LIFNode::create_pipeline(opt); if (ret) return ret; }
        return 0;
    }
    virtual int destroy_pipeline(const Option& opt) {
        { int ret = LIFNode::destroy_pipeline(opt); if (ret) return ret; }
        return 0;
    }
};
DEFINE_LAYER_CREATOR(LIFNode_final)
} // namespace ncnn


